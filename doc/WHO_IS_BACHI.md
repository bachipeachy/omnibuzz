**About**

I design systems meant to outlast the code that builds them.

My career began in industrial automation---across iron & steel, cement,
and petrochemical plants---where I designed motor control and automation
systems and contributed patented work. Those systems taught me something
software often forgets: when abstractions are correct, systems can run
deterministically for decades without change.

I later spent over 28 years at **The Boeing Company**, working at the
intersection of control systems, large-scale engineering, and computing
architecture, ultimately serving as a **Technical Fellow**. Over time, a
contrast became impossible to ignore.

The industrial control systems I designed early in my career are still
running---unchanged, reliable, deterministic.\
Business software written five years ago is often considered legacy.

The difference isn't engineering talent. It's architectural philosophy.

Control systems separate **what should happen** from **how it happens**.
Business software tangles them together, embedding domain logic in
imperative code that becomes increasingly hard to reason about, verify,
or evolve.

There's a simple analogy most software systems ignore:\
we don't design a unique operating system for every application---so why
do we design unique execution logic for every business system?

Operating systems exist precisely to separate intent from mechanism.
Applications declare what they need; the OS governs how execution
occurs---consistently, deterministically, and independently of any
single application's logic. Business software, by contrast, repeatedly
reinvents its own execution machinery, embedding behavior directly into
code and paying the price in fragility and decay.

**OmniBachi** is my answer to three decades of watching software decay
unnecessarily.

It is a protocol-governed execution model where business logic exists as
validated declarative data---not code. Where workflows are
mathematically constrained before they run. Where a single execution
engine---written once---executes across domains with deterministic
precision and a complete audit trail.

The reference implementation formalizes this architecture: protocol
authority as the source of truth, semantically blind execution,
contract-bound capabilities, and derived consequences. But the deeper
work is philosophical---arguing that **protocols, not code, should be
the substrate of business systems**.

I write about these ideas in the **OmniBuzz** series: the economics of
protocol-driven computing, the mathematics of deterministic execution,
and why 10,000 workflows shouldn't require 10,000,000 lines of code.

Outside engineering, I write fiction under the pen name *Bachi* and
practice regenerative backyard gardening---both exercises in building
systems that sustain themselves over time.

**Education:** B.Tech, Electrical Engineering, IIT Madras\
ðŸ“© **Contact:** <bachi.bachi@myyahoo.com>
