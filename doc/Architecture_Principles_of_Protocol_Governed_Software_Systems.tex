\documentclass[11pt,twocolumn]{article}

% ============================================================
% PACKAGES
% ============================================================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{array}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{microtype}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{abstract}
\usepackage{natbib}
\usepackage{url}
\usepackage{balance}

% ============================================================
% HYPERREF CONFIGURATION
% ============================================================
\hypersetup{
    colorlinks=true,
    linkcolor=blue!70!black,
    citecolor=green!50!black,
    urlcolor=blue!70!black,
    pdftitle={Architectural Principles of Protocol-Governed Software Systems},
    pdfauthor={Bachi},
    pdfsubject={Software Architecture},
    pdfkeywords={protocol governance, software architecture, declarative systems, formal specification}
}

% ============================================================
% THEOREM ENVIRONMENTS
% ============================================================
\theoremstyle{definition}
\newtheorem{principle}{Principle}
\newtheorem{definition}{Definition}

% ============================================================
% CUSTOM COMMANDS
% ============================================================
\newcommand{\eg}{\textit{e.g.}}
\newcommand{\ie}{\textit{i.e.}}
\newcommand{\cf}{\textit{cf.}}
\newcommand{\etal}{\textit{et al.}}

% ============================================================
% TITLE SECTION FORMATTING
% ============================================================
\titleformat{\section}{\normalfont\large\bfseries}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\normalfont\normalsize\bfseries}{\thesubsection}{0.5em}{}
\titleformat{\subsubsection}{\normalfont\normalsize\itshape}{\thesubsubsection}{0.5em}{}

% ============================================================
% HEADER/FOOTER
% ============================================================
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\fancyfoot[C]{\thepage}

% ============================================================
% ABSTRACT FORMATTING
% ============================================================
\renewcommand{\abstractnamefont}{\normalfont\bfseries}
\renewcommand{\abstracttextfont}{\normalfont\small}
\setlength{\absleftindent}{0pt}
\setlength{\absrightindent}{0pt}

% ============================================================
% DOCUMENT BEGIN
% ============================================================
\begin{document}

% ============================================================
% TITLE
% ============================================================
\twocolumn[
\begin{@twocolumnfalse}
\begin{center}
{\LARGE\bfseries Architectural Principles of Protocol-Governed\\[0.3em] Software Systems\par}
\vspace{1em}
{\large\itshape From Imperative Code to Governed Behavior\par}
\vspace{1.5em}
{\large Bachi\par}
\vspace{0.5em}
{\normalsize Independent Researcher\\
\texttt{bachi.protocol@protonmail.com}\par}
\vspace{1.5em}
\end{center}

% ============================================================
% ABSTRACT
% ============================================================
\begin{abstract}
\noindent Contemporary software systems encode business behavior implicitly within imperative implementations, binding system semantics to execution mechanics that evolve rapidly and often invisibly. This architectural pattern renders behavior difficult to audit, reason about, or preserve under refactoring---an issue dramatically amplified by the rise of AI-generated code, where studies suggest that automated code generation will constitute the majority of production code within the decade~\citep{github2023copilot}.

Building on prior work introducing protocol-governed software systems~\citep{bachi2025protocol}, this paper extends the foundational model by articulating the \textbf{architectural principles and governance structure} required to make such systems durable in practice. Protocol-governed software systems define behavior through explicit, declarative, version-controlled artifacts that are authoritative over execution, enforcing a constitutional separation between behavioral intent and implementation strategy.

We formalize nine principles that directly address known failure modes of imperative architectures and analyze their implications for scalability, security, auditability, total cost of ownership, and long-term system evolution. We further introduce a \textbf{constitutional model} that clarifies the roles of protocol artifacts as law, validation and conformance as enforcement, traces as admissible evidence, and non-conformance as a structural remedy rather than an operational failure.

Rather than proposing new tools or programming languages, this work defines \textbf{constitutional constraints} that determine whether a software system remains governable as implementations, platforms, and AI-generated code evolve. The result is an architectural framework for software systems whose behavior remains explicit, deterministic, auditable, and enforceable across execution strategies and technological change.

\vspace{0.8em}
\noindent\textbf{Keywords:} protocol governance, software architecture, declarative systems, behavioral specification, formal methods, AI code generation, software auditability, constitutional computing
\end{abstract}
\vspace{1.5em}
\end{@twocolumnfalse}
]

% ============================================================
% CONTRIBUTIONS BOX
% ============================================================
\noindent\fbox{\parbox{0.96\columnwidth}{
\textbf{Contributions.} This paper makes the following contributions:
\begin{enumerate}[leftmargin=*, nosep, topsep=2pt]
    \item A formal articulation of nine constitutional principles for protocol-governed software systems
    \item A constitutional model mapping governance structures to technical enforcement mechanisms
    \item Systematic analysis of failure modes in imperative architectures that these principles address
    \item An economic model comparing front-loaded governance cost to technical debt accrual
\end{enumerate}
}}
\vspace{0.8em}

% ============================================================
% SECTION 1: INTRODUCTION
% ============================================================
\section{Introduction}
\label{sec:introduction}

Modern software engineering operates under a tacit assumption: \textit{to understand what a system does, one must read its code}. Business rules, constraints, and failure semantics are embedded within imperative logic, distributed across services, and intertwined with execution details. Studies estimate that 60--80\% of software maintenance cost stems from understanding existing behavior rather than implementing changes~\citep{erlikh2000leveraging, glass2002facts}.

This assumption was tolerable when systems were small, codebases were stable, and changes were human-authored. It is increasingly untenable today.

As established in prior work~\citep{bachi2025protocol}, this architectural coupling produces systemic failures:

\begin{itemize}[leftmargin=*, nosep]
    \item Behavior cannot be independently audited
    \item Refactoring risks semantic drift
    \item Compliance requires implementation inspection
    \item No authoritative artifact defines preserved behavior
\end{itemize}

The emergence of large language models capable of generating and refactoring production code at scale exacerbates these issues~\citep{chen2021evaluating, github2023copilot}. Code evolves faster than humans can meaningfully audit it, while tests verify only sampled behavior, not semantic completeness~\citep{weyuker1982adequacy}.

This paper advances the argument that the core failure is \textbf{architectural}, not procedural. The remedy is not better testing, code reviews, or observability tooling, but a different architectural constitution---one in which behavior is explicitly governed.

% ============================================================
% SECTION 2: FAILURE MODES
% ============================================================
\section{Failure Modes of Imperative Architectures}
\label{sec:failure-modes}

Imperative software architectures fail not because of poor engineering discipline, but because they \textbf{structurally embed meaning in execution}. We define this embedding precisely:

\begin{definition}[Semantic Embedding]
\label{def:semantic-embedding}
A system exhibits \textit{semantic embedding} when the authoritative specification of its behavior exists only as executable code, such that understanding, auditing, or verifying behavior requires inspection of implementation artifacts.
\end{definition}

This section makes explicit the failure modes that protocol-governed principles are designed to address.

\subsection{Behavior Is Implicit and Non-Authoritative}

In imperative systems, behavior is inferred from control flow, conditional logic, and side effects scattered across codebases~\citep{parnas1972criteria}. No single artifact authoritatively defines system intent.

\textbf{Consequences:}
\begin{itemize}[leftmargin=*, nosep]
    \item Audits require code inspection
    \item Behavioral understanding is person-dependent
    \item Documentation is descriptive, not binding
\end{itemize}

\subsection{Semantic Drift During Refactoring}

Refactoring changes \textit{how} code executes, but often unintentionally alters \textit{what} it means~\citep{fowler1999refactoring}. Tests may pass while edge-case semantics shift---a phenomenon we term \textit{semantic drift}.

\textbf{Consequences:}
\begin{itemize}[leftmargin=*, nosep]
    \item Undetected behavioral regressions
    \item High cost of safe evolution
    \item Fragile long-lived systems
\end{itemize}

\subsection{Tests as Incomplete Behavioral Oracles}

Tests sample behavior; they do not define it~\citep{dijkstra1970notes}. Passing tests do not imply semantic completeness or invariance under execution strategy changes. As Dijkstra observed, testing can demonstrate the presence of bugs but never their absence.

\textbf{Consequences:}
\begin{itemize}[leftmargin=*, nosep]
    \item False confidence in correctness
    \item Underspecified edge cases
    \item Inability to prove equivalence across implementations
\end{itemize}

\subsection{Distributed Implicit Behavior}

Microservice architectures distribute logic across independently evolving components~\citep{newman2015microservices, fowler2014microservices}, amplifying implicit behavior and inter-service assumptions.

\textbf{Consequences:}
\begin{itemize}[leftmargin=*, nosep]
    \item Emergent behavior not visible in any single service
    \item Version skew induces semantic inconsistency
    \item System behavior becomes non-local and opaque
\end{itemize}

\subsection{AI-Generated Code as an Amplifier}

AI-generated code compounds all of the above~\citep{chen2021evaluating, pearce2022asleep}. While syntactically valid and test-passing, generated code may subtly reinterpret intent without explicit indication.

\textbf{Consequences:}
\begin{itemize}[leftmargin=*, nosep]
    \item Human review does not scale
    \item Semantic drift accelerates
    \item Governance collapses without external behavioral authority
\end{itemize}

These failure modes are not accidental; they are consequences of architecture. Protocol-governed principles respond directly to these structural defects.

% ============================================================
% SECTION 3: CORE PREMISE
% ============================================================
\section{Protocol-Governed Architecture: Core Premise}
\label{sec:core-premise}

Protocol-governed systems enforce a constitutional separation between:

\begin{itemize}[leftmargin=*, nosep]
    \item \textbf{WHAT} the system does (behavior, rules, constraints)
    \item \textbf{HOW} the system does it (execution strategy, optimization, platform)
\end{itemize}

This separation echoes the platform-independent model (PIM) and platform-specific model (PSM) distinction in Model-Driven Architecture~\citep{omg2014mda}, but extends it by making the behavioral specification \textit{authoritative and executable} rather than merely generative.

Behavior is expressed through \textbf{declarative protocol artifacts} that are authoritative and version-controlled. Execution engines interpret these artifacts but do not define meaning.

\begin{definition}[Behavioral Equivalence]
\label{def:behavioral-equivalence}
For any protocol $P$, input set $I$, and conformant execution engines $E_1, E_2$, we define behavioral equivalence as:
\[
\mathit{trace}(E_1(P, I)) \cong \mathit{trace}(E_2(P, I))
\]
where $\cong$ denotes schema-defined observational equivalence over externally visible state transitions and effects.
\end{definition}

Auditing behavior therefore requires inspecting protocol artifacts---not execution code. This property is fundamental: it enables behavioral governance independent of implementation strategy.

% ============================================================
% SECTION 4: CONSTITUTIONAL PRINCIPLES
% ============================================================
\section{Constitutional Principles}
\label{sec:principles}

We now articulate nine constitutional principles for protocol-governed software systems. Each principle directly addresses one or more failure modes identified in \Cref{sec:failure-modes}.

\begin{principle}[Explicit and Authoritative Behavior]
\label{principle:explicit}
System behavior must be defined in declarative artifacts that are the single source of truth. Execution code is derivative and non-authoritative.
\end{principle}
\textit{Addresses:} implicit behavior, audit opacity (\S\ref{sec:failure-modes})

\begin{principle}[Structurally Bounded Complexity]
\label{principle:bounded}
Behavioral expressiveness is constrained by protocol vocabulary and schema. What cannot be expressed cannot execute.
\end{principle}
\textit{Addresses:} unbounded complexity, hidden interactions. This principle aligns with the principle of least authority~\citep{miller2006robust} applied to behavioral specification.

\begin{principle}[Semantic Blindness of Execution]
\label{principle:blind}
Execution engines interpret protocols without encoding domain meaning. Engines are generic interpreters, not domain-aware reasoners.
\end{principle}
\textit{Addresses:} engine-domain coupling, fragile evolution

\begin{principle}[Constitutional Determinism]
\label{principle:determinism}
Given identical protocol artifacts and inputs, all conformant executions must produce identical externally observable results unless non-determinism is explicitly declared and bounded.
\end{principle}
\textit{Addresses:} semantic drift, unverifiable refactoring. This formalizes requirements implicit in replay debugging~\citep{ronsse1999recplay} and extends them to cross-engine equivalence.

\begin{principle}[Governance Precedence]
\label{principle:governance}
Structural correctness, determinism, and auditability are enforced before optimization. Performance is a second-order concern.
\end{principle}
\textit{Addresses:} correctness sacrificed for speed

\begin{principle}[Explicit Protocol Evolution]
\label{principle:evolution}
Behavioral change occurs through new protocol versions, not code modification. Multiple protocol generations may coexist under explicit compatibility rules.
\end{principle}
\textit{Addresses:} forced migrations, breaking changes. This extends semantic versioning~\citep{preston2013semver} to behavioral specification.

\begin{principle}[Vocabulary-Bounded Attack Surface]
\label{principle:vocabulary}
Protocol vocabulary defines the complete space of possible behaviors. Vocabulary expansion requires governance approval.
\end{principle}
\textit{Addresses:} security sprawl, unintended capability growth. This principle operationalizes the principle of least privilege~\citep{saltzer1975protection} at the behavioral level.

\begin{principle}[Universal Observability]
\label{principle:observable}
Execution engines must emit schema-governed traces capturing all state transitions and side effects. No execution may be unobserved.
\end{principle}
\textit{Addresses:} post-hoc forensics, unverifiable behavior

\begin{principle}[Explicit Side Effects]
\label{principle:effects}
All state mutations and external interactions are declared and deterministically ordered within the protocol specification.
\end{principle}
\textit{Addresses:} hidden state, ambient authority~\citep{miller2006robust}

% ============================================================
% SECTION 5: RELATED WORK
% ============================================================
\section{Related Work}
\label{sec:related-work}

Protocol-governed architecture draws on and extends several research traditions while maintaining a distinct focus on behavioral authority.

\subsection{Workflow and Orchestration Systems}

Workflow engines such as those based on Petri nets~\citep{vanderaalst2003workflow} and BPMN~\citep{omg2011bpmn} govern orchestration and control flow but typically delegate semantic authority to the code invoked at each step. Protocol-governed systems extend governance to the behavioral semantics of each step, not merely their sequencing.

\subsection{Formal Specification Languages}

TLA+~\citep{lamport2002specifying}, Alloy~\citep{jackson2012software}, and Z~\citep{spivey1989z} enable rigorous behavioral specification but traditionally separate specification from execution. Protocol-governed architecture requires that specifications \textit{are} the execution authority---not merely documentation or verification targets.

\subsection{Design by Contract}

Meyer's Design by Contract~\citep{meyer1992applying} introduced explicit preconditions, postconditions, and invariants as first-class language constructs. Protocol governance generalizes this approach: entire system behaviors, not just method boundaries, are contractually specified.

\subsection{Model-Driven Architecture}

The OMG's Model-Driven Architecture~\citep{omg2014mda} separates platform-independent models from platform-specific implementations. However, MDA focuses on code generation rather than behavioral authority---the generated code becomes authoritative. Protocol governance inverts this: the model remains authoritative throughout execution.

\subsection{Domain-Specific Languages}

DSLs~\citep{fowler2010dsl} constrain expressiveness to domain-appropriate constructs. Protocol governance shares this philosophy but emphasizes \textit{governance} over \textit{expressiveness}: the protocol defines what is permitted, not merely what is convenient.

\subsection{Smart Contracts and Blockchain}

Blockchain-based smart contracts~\citep{buterin2014ethereum, szabo1997smart} represent an execution model where code-as-law is taken literally. However, smart contracts still embed behavior in executable code. Protocol governance separates the behavioral specification from execution, enabling multiple conformant execution engines.

\subsection{Choreography and Service Contracts}

WS-CDL~\citep{w3c2005wscdl} and similar choreography languages specify multi-party interaction protocols. Protocol governance extends this approach to include intra-system behavior, not just inter-service coordination.

The distinguishing characteristic of protocol-governed architecture is the \textbf{unification of specification and execution authority}: the protocol artifact is simultaneously the specification, the governance instrument, and the execution directive.

% ============================================================
% SECTION 6: IMPLICATIONS
% ============================================================
\section{Implications}
\label{sec:implications}

\subsection{Scalability: Compositional Complexity Management}

Imperative systems scale by duplicating logic, leading to combinatorial interaction growth~\citep{brooks1987nosilvenbullet}. Protocol-governed systems scale by \textbf{composing behavior from stable primitives}.

We hypothesize that well-formed protocol-governed systems exhibit sub-linear complexity growth relative to system size, as new behaviors compose from existing vocabulary rather than introducing novel interactions. Formal verification of this hypothesis remains future work, but the architectural structure is designed to enable it.

\subsection{Security as a Structural Property}

Security emerges from architectural constraint rather than defensive programming:
\begin{itemize}[leftmargin=*, nosep]
    \item No undeclared effects (Principle~\ref{principle:effects})
    \item No ambient authority (Principle~\ref{principle:vocabulary})
    \item No implicit control flow (Principle~\ref{principle:explicit})
\end{itemize}

Attack surfaces remain bounded as systems grow because vocabulary expansion requires explicit governance. This operationalizes capability-based security principles~\citep{dennis1966programming, miller2006robust} at the architectural level.

\subsection{Auditability and Provenance}

Deterministic, schema-governed traces (Principle~\ref{principle:observable}) enable:
\begin{itemize}[leftmargin=*, nosep]
    \item Behavioral replay for debugging and verification
    \item Cross-engine equivalence testing
    \item Mathematical audit without implementation inspection
\end{itemize}

Behavior becomes provable without code review, addressing a fundamental limitation of imperative systems.

\subsection{AI-Generated Code Containment}

Under protocol governance, AI becomes an \textbf{execution optimizer} constrained by protocol authority, not a semantic authority itself. The protocol defines \textit{what} must occur; AI may optimize \textit{how} it occurs within conformance bounds.

Behavioral equivalence (Definition~\ref{def:behavioral-equivalence}) is verified mechanically through trace comparison, independent of whether code was human-authored or AI-generated. This provides a governance framework for the emerging reality of AI-assisted software development~\citep{github2023copilot}.

% ============================================================
% SECTION 7: ECONOMIC MODEL
% ============================================================
\section{Economic Model}
\label{sec:economics}

Traditional systems minimize upfront modeling cost but accrue compounding technical debt over time~\citep{cunningham1992wycash}. Protocol-governed systems invert this curve by front-loading explicit behavioral definition.

Following Boehm's cost estimation models~\citep{boehm1981software}, we observe that defect correction cost increases exponentially with project phase. Protocol governance shifts behavioral specification to the earliest phase, where correction cost is minimal.

The hypothesized result is:
\begin{itemize}[leftmargin=*, nosep]
    \item Stabilized execution code (behavior changes require protocol amendments, not code changes)
    \item Reduced regression cost (conformance testing replaces regression testing)
    \item Flattened long-term total cost of ownership
\end{itemize}

We characterize this as \textbf{paying principal rather than interest}: higher initial investment in explicit specification yields compounding returns through reduced maintenance burden.

This model favors long-lived, governed systems where stability and auditability are primary concerns. It may impose overhead inappropriate for exploratory or short-lived systems.

% ============================================================
% SECTION 8: CONSTITUTIONAL MODEL
% ============================================================
\section{A Constitutional Model for Protocol-Governed Systems}
\label{sec:constitutional}

To clarify the governance structure underlying protocol-governed software systems, we introduce a \textbf{constitutional model}. This model is not merely illustrative rhetoric; it maps directly to architectural roles, enforcement mechanisms, and verification artifacts.

The model distinguishes between \textbf{authority}, \textbf{law}, \textbf{enforcement}, \textbf{evidence}, and \textbf{remedy}---dimensions that imperative software architectures typically conflate or leave implicit.

\Cref{tab:constitutional-mapping} summarizes the mapping between legal concepts and protocol-governed system artifacts.

\begin{table}[t]
\centering
\caption{Mapping of Constitutional Concepts to Protocol-Governed Artifacts}
\label{tab:constitutional-mapping}
\begin{tabular}{@{}p{0.28\columnwidth}p{0.62\columnwidth}@{}}
\toprule
\textbf{Legal Concept} & \textbf{Protocol-Governed Analog} \\
\midrule
Constitution & Schema constraints, separation axioms, non-intersecting governance axes \\
\addlinespace
Legislation & Versioned protocol artifacts (workflows, capabilities, events) \\
\addlinespace
Enforcement & Validators, runtime guards, conformance engines \\
\addlinespace
Evidence & Schema-governed execution traces \\
\addlinespace
Remedy & Non-conformance rejection, execution abort, version invalidation \\
\bottomrule
\end{tabular}
\end{table}

\subsection{The Constitution: Scope of Governable Behavior}

The \textbf{constitution} defines the non-negotiable structure of the system. It establishes \textit{which concerns exist}, \textit{how they are separated}, and \textit{which interactions are permitted}.

Constitutional concerns form \textbf{non-intersecting axes}. Each axis governs a distinct dimension of system behavior and may not override or subsume another:
\begin{itemize}[leftmargin=*, nosep]
    \item Protocol structure and vocabulary
    \item Execution determinism requirements
    \item Side-effect declaration and ordering
    \item Purity constraints for transformations
    \item Observability and trace requirements
    \item Governance and evolution rules
\end{itemize}

Together, these axes define the \textbf{scope of behavioral authority}.

The constitution functions as a \textit{bill of rights} for protocol-governed systems:
\begin{itemize}[leftmargin=*, nosep]
    \item Execution engines may not reinterpret behavior
    \item Side effects may not be implicit
    \item Non-determinism may not be accidental
    \item Behavior may not be inferred from implementation
\end{itemize}

Any system that violates constitutional constraints is \textbf{non-conformant}, regardless of correctness, performance, or operational success.

\subsection{Legislation: Protocol Artifacts as Law}

Flowing from the constitution are \textbf{legislation and ordinances}: the concrete, versioned artifacts that define system behavior. These include:
\begin{itemize}[leftmargin=*, nosep]
    \item Workflows and orchestration specifications
    \item Capability contracts and atoms
    \item Event definitions and state transitions
    \item Vocabulary schemas and invariants
\end{itemize}

Each artifact is authoritative within its declared scope, independently versioned, and constrained by constitutional rules. These artifacts are \textbf{binding}, not descriptive---they declare \textit{what must occur}, not \textit{how it is executed}.

Multiple ordinances may coexist, evolve, or be repealed without altering execution machinery, provided constitutional constraints are upheld.

\subsection{Enforcement: Validation and Conformance}

A constitution without enforcement is aspirational. Protocol-governed systems include \textbf{explicit enforcement mechanisms} at multiple stages.

\textbf{Authoring-Time Enforcement.} Protocol artifacts are validated prior to execution:
\begin{itemize}[leftmargin=*, nosep]
    \item Structural correctness verification
    \item Vocabulary compliance checking
    \item Determinism constraint validation
    \item Side effect declaration completeness
\end{itemize}
Invalid legislation cannot be enacted.

\textbf{Runtime Enforcement.} Execution engines enforce:
\begin{itemize}[leftmargin=*, nosep]
    \item Declared execution order
    \item Effect boundaries
    \item Deterministic semantics
\end{itemize}
Execution that violates protocol law is rejected or aborted.

\textbf{Post-Execution Conformance.} Behavioral equivalence is verified through trace capture, replay, and cross-engine comparison. Conformance artifacts provide objective evidence that execution adhered to protocol law.

\subsection{Evidence: Traces as Sworn Testimony}

In the event of dispute, audit, or compliance review, protocol-governed systems rely on \textbf{execution traces} as evidence.

Traces are:
\begin{itemize}[leftmargin=*, nosep]
    \item Schema-governed (structure is constitutionally defined)
    \item Deterministic (identical inputs produce identical traces)
    \item Externally observable (no hidden state)
    \item Reproducible (replay is guaranteed)
\end{itemize}

Unlike logs or telemetry in imperative systems---which are partial, informal, and implementation-dependent---protocol traces are \textbf{constitutional evidence}. They are admissible because they are produced under governance, not at developer discretion.

This enables mathematical audit, behavioral replay, and independent verification.

\subsection{Remedy: Structural Consequences}

Software systems do not punish actors; they enforce \textbf{structural consequences}. Violations result in remedial measures, not discretionary responses.

\textbf{Non-Conformance.} Any artifact, execution, or engine that violates constitutional constraints is declared non-conformant and is:
\begin{itemize}[leftmargin=*, nosep]
    \item Rejected from certification
    \item Excluded from production execution
    \item Barred from interoperability
\end{itemize}

\textbf{Execution Rejection.} At runtime, violations trigger deterministic responses: execution abort, rollback, or quarantine of side effects. These responses are protocol-declared, not situational.

\textbf{Governance Remedies.} At the protocol level, remediation may include version invalidation, forced deprecation, or mandatory amendment prior to reenactment.

\subsection{Amendment and Evolution}

Unlike legal systems, protocol-governed systems have well-defined amendment procedures. Constitutional changes require:
\begin{itemize}[leftmargin=*, nosep]
    \item Explicit version incrementation
    \item Migration path specification
    \item Backward compatibility declaration or breaking change acknowledgment
\end{itemize}

There is no appeal outside the constitution, but the constitution itself may evolve through governed process. This distinguishes protocol governance from rigid systems that cannot adapt.

% ============================================================
% SECTION 9: APPLICABILITY
% ============================================================
\section{Applicability and Limitations}
\label{sec:applicability}

Protocol-governed architecture is not universally appropriate. This section delineates its intended scope and acknowledges limitations.

\subsection{Appropriate Domains}

The architecture is optimized for systems requiring:
\begin{itemize}[leftmargin=*, nosep]
    \item Long-term auditability and compliance
    \item Deterministic, reproducible behavior
    \item Multi-stakeholder governance
    \item Resistance to semantic drift under evolution
    \item AI-assisted development with behavioral guarantees
\end{itemize}

Examples include financial systems, healthcare records, regulatory compliance systems, and critical infrastructure.

\subsection{Inappropriate Domains}

The architecture imposes overhead inappropriate for:
\begin{itemize}[leftmargin=*, nosep]
    \item Exploratory programming and prototyping
    \item Unconstrained algorithmic research
    \item Systems where rapid iteration outweighs governance
    \item Short-lived or disposable applications
\end{itemize}

\subsection{Acknowledged Limitations}

\textbf{Governance Burden.} Protocol authoring requires explicit behavioral specification, imposing upfront cost that may not be justified for all systems.

\textbf{Expressiveness Constraints.} Vocabulary-bounded behavior (\Cref{principle:bounded}) may prevent expression of legitimately needed capabilities until governance approves vocabulary expansion.

\textbf{Tooling Maturity.} The ecosystem for protocol-governed development is nascent compared to imperative programming environments.

\textbf{Empirical Validation.} The claims in this paper are architecturally motivated but await systematic empirical validation through case studies and comparative analysis.

% ============================================================
% SECTION 10: FUTURE WORK
% ============================================================
\section{Future Work}
\label{sec:future}

Several research directions extend the foundation presented here:

\begin{itemize}[leftmargin=*, nosep]
    \item \textbf{Formal Semantics:} Development of a formal semantics for protocol languages enabling mechanical proof of behavioral properties
    \item \textbf{Empirical Studies:} Comparative case studies measuring maintenance cost, defect rates, and evolution velocity between protocol-governed and imperative implementations
    \item \textbf{Tooling Ecosystem:} Development of authoring environments, validators, and execution engines optimized for protocol-governed workflows
    \item \textbf{AI Integration:} Systematic study of AI code generation under protocol constraint, including conformance verification methods
    \item \textbf{Cross-Organization Governance:} Extension of constitutional models to multi-stakeholder, federated governance scenarios
\end{itemize}

% ============================================================
% SECTION 11: CONCLUSION
% ============================================================
\section{Conclusion}
\label{sec:conclusion}

Protocol-governed architecture addresses a foundational failure of modern software systems: the embedding of system meaning within transient execution code. As implementation strategies evolve---through refactoring, optimization, platform migration, or AI-assisted generation---this coupling causes behavior to drift beyond reliable governance.

By restoring behavior to explicit, declarative, and governed protocol artifacts, protocol-governed software systems reestablish determinism, auditability, and long-term semantic stability as architectural properties rather than operational aspirations. Execution becomes an interchangeable mechanism constrained by protocol law, while validation, conformance, and traceability provide objective enforcement and evidence.

The constitutional model introduced in this paper makes explicit what imperative systems leave implicit: software systems allocate authority, define permissible behavior, and enforce consequences. When these structures remain unwritten, governance collapses under scale and automation. When made explicit, bounded, and enforceable, systems can evolve without losing meaning.

In an era where code generation increasingly outpaces human review, protocol governance offers a path toward software systems that remain intelligible, trustworthy, and governable across implementation generations---not by slowing change, but by constraining it lawfully.

% ============================================================
% ACKNOWLEDGMENTS
% ============================================================
\section*{Acknowledgments}

The author thanks the reviewers for their constructive feedback and the open-source community for ongoing dialogue on software architecture principles.

% ============================================================
% REFERENCES
% ============================================================
\bibliographystyle{plainnat}
\begin{thebibliography}{30}

\bibitem[Bachi(2025)]{bachi2025protocol}
Bachi.
\newblock Protocol-governed software: Separating system behavior from execution mechanics.
\newblock Technical report, 2025.
\newblock Preprint available at [repository].

\bibitem[Boehm(1981)]{boehm1981software}
Barry~W. Boehm.
\newblock \emph{Software Engineering Economics}.
\newblock Prentice-Hall, 1981.

\bibitem[Brooks(1987)]{brooks1987nosilvenbullet}
Frederick~P. Brooks.
\newblock No silver bullet: Essence and accidents of software engineering.
\newblock \emph{Computer}, 20(4):10--19, 1987.

\bibitem[Buterin(2014)]{buterin2014ethereum}
Vitalik Buterin.
\newblock A next-generation smart contract and decentralized application platform.
\newblock Ethereum White Paper, 2014.

\bibitem[Chen et~al.(2021)]{chen2021evaluating}
Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de~Oliveira~Pinto, Jared Kaplan, et~al.
\newblock Evaluating large language models trained on code.
\newblock \emph{arXiv preprint arXiv:2107.03374}, 2021.

\bibitem[Cunningham(1992)]{cunningham1992wycash}
Ward Cunningham.
\newblock The {WyCash} portfolio management system.
\newblock \emph{OOPSLA Experience Report}, 1992.

\bibitem[Dennis and Van~Horn(1966)]{dennis1966programming}
Jack~B. Dennis and Earl~C. Van~Horn.
\newblock Programming semantics for multiprogrammed computations.
\newblock \emph{Communications of the ACM}, 9(3):143--155, 1966.

\bibitem[Dijkstra(1970)]{dijkstra1970notes}
Edsger~W. Dijkstra.
\newblock Notes on structured programming.
\newblock Technical Report EWD249, Technological University Eindhoven, 1970.

\bibitem[Erlikh(2000)]{erlikh2000leveraging}
Len Erlikh.
\newblock Leveraging legacy system dollars for e-business.
\newblock \emph{IT Professional}, 2(3):17--23, 2000.

\bibitem[Fowler(1999)]{fowler1999refactoring}
Martin Fowler.
\newblock \emph{Refactoring: Improving the Design of Existing Code}.
\newblock Addison-Wesley, 1999.

\bibitem[Fowler(2010)]{fowler2010dsl}
Martin Fowler.
\newblock \emph{Domain-Specific Languages}.
\newblock Addison-Wesley, 2010.

\bibitem[Fowler and Lewis(2014)]{fowler2014microservices}
Martin Fowler and James Lewis.
\newblock Microservices: A definition of this new architectural term.
\newblock \url{https://martinfowler.com/articles/microservices.html}, 2014.

\bibitem[GitHub(2023)]{github2023copilot}
GitHub.
\newblock GitHub {Copilot} research recitation.
\newblock Technical report, GitHub, 2023.

\bibitem[Glass(2002)]{glass2002facts}
Robert~L. Glass.
\newblock \emph{Facts and Fallacies of Software Engineering}.
\newblock Addison-Wesley, 2002.

\bibitem[Jackson(2012)]{jackson2012software}
Daniel Jackson.
\newblock \emph{Software Abstractions: Logic, Language, and Analysis}.
\newblock MIT Press, revised edition, 2012.

\bibitem[Lamport(2002)]{lamport2002specifying}
Leslie Lamport.
\newblock \emph{Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers}.
\newblock Addison-Wesley, 2002.

\bibitem[Meyer(1992)]{meyer1992applying}
Bertrand Meyer.
\newblock Applying ``{Design by Contract}''.
\newblock \emph{Computer}, 25(10):40--51, 1992.

\bibitem[Miller et~al.(2006)]{miller2006robust}
Mark~S. Miller, Ka-Ping Yee, and Jonathan Shapiro.
\newblock Capability myths demolished.
\newblock Technical Report SRL2003-02, Johns Hopkins University, 2006.

\bibitem[Newman(2015)]{newman2015microservices}
Sam Newman.
\newblock \emph{Building Microservices: Designing Fine-Grained Systems}.
\newblock O'Reilly Media, 2015.

\bibitem[OMG(2011)]{omg2011bpmn}
Object Management~Group (OMG).
\newblock Business process model and notation ({BPMN}) version 2.0.
\newblock OMG Standard, 2011.

\bibitem[OMG(2014)]{omg2014mda}
Object Management~Group (OMG).
\newblock Model driven architecture ({MDA}) guide revision 2.0.
\newblock OMG Document ormsc/14-06-01, 2014.

\bibitem[Parnas(1972)]{parnas1972criteria}
David~L. Parnas.
\newblock On the criteria to be used in decomposing systems into modules.
\newblock \emph{Communications of the ACM}, 15(12):1053--1058, 1972.

\bibitem[Pearce et~al.(2022)]{pearce2022asleep}
Hammond Pearce, Baleegh Ahmad, Benjamin Tan, Brendan Dolan-Gavitt, and Ramesh Karri.
\newblock Asleep at the keyboard? {Assessing} the security of {GitHub Copilot}'s code contributions.
\newblock In \emph{IEEE Symposium on Security and Privacy}, pages 754--768, 2022.

\bibitem[Preston-Werner(2013)]{preston2013semver}
Tom Preston-Werner.
\newblock Semantic versioning 2.0.0.
\newblock \url{https://semver.org/}, 2013.

\bibitem[Ronsse and De~Bosschere(1999)]{ronsse1999recplay}
Michiel Ronsse and Koen De~Bosschere.
\newblock {RecPlay}: A fully integrated practical record/replay system.
\newblock \emph{ACM Transactions on Computer Systems}, 17(2):133--152, 1999.

\bibitem[Saltzer and Schroeder(1975)]{saltzer1975protection}
Jerome~H. Saltzer and Michael~D. Schroeder.
\newblock The protection of information in computer systems.
\newblock \emph{Proceedings of the IEEE}, 63(9):1278--1308, 1975.

\bibitem[Spivey(1989)]{spivey1989z}
J.~Michael Spivey.
\newblock \emph{The Z Notation: A Reference Manual}.
\newblock Prentice Hall, 1989.

\bibitem[Szabo(1997)]{szabo1997smart}
Nick Szabo.
\newblock Formalizing and securing relationships on public networks.
\newblock \emph{First Monday}, 2(9), 1997.

\bibitem[van~der Aalst et~al.(2003)]{vanderaalst2003workflow}
Wil M.~P. van~der Aalst, Arthur H.~M. ter~Hofstede, Bartek Kiepuszewski, and Alistair~P. Barros.
\newblock Workflow patterns.
\newblock \emph{Distributed and Parallel Databases}, 14(1):5--51, 2003.

\bibitem[W3C(2005)]{w3c2005wscdl}
World Wide Web Consortium (W3C).
\newblock Web services choreography description language version 1.0.
\newblock W3C Candidate Recommendation, 2005.

\bibitem[Weyuker(1982)]{weyuker1982adequacy}
Elaine~J. Weyuker.
\newblock On testing non-testable programs.
\newblock \emph{The Computer Journal}, 25(4):465--470, 1982.

\end{thebibliography}

\end{document}
